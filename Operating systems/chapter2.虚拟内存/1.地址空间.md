# 地址空间

在早期，计算机是非常简单的，操作系统看起来就像是一种应用函数库，只有一整块的物理内存。在物理内存中，存有操作系统的代码和数据，然后还有正在运行的程序（包括它的代码和数据）。这里没有抽象，程序是直接使用物理內存的。当然，这是一个非常简单的结构，程序可以随意地使用它的內存，并不会带来什么问题。

但是，随着多道程序系统时代的开启，分时系统时代的到来，多个程序同时留在内存中，便出现了问题，这就有可能发生“打架”，互相抢占内存资源，这无疑是危险的。此时，关于內存的抽象便出现了，我们需要用一种抽象来管理內存，将“有限”的物理内存变成“无限”的虚拟内存，让程序美滋滋地感觉到自己占用了全部的內存，而不知道真实的物理内存上另一程序的存在。

这个抽象是地址空间，我们可以想象为一块巨大的內存。操作系统分配给程序一块地址空间，然后程序可以在它的地址空间中随意地划分內存。每个程序独占一个地址空间，所以也就不会跟别的程序发生冲突，实现了相互隔离。



![](https://s2.loli.net/2022/03/17/A4BePFRbuymifaV.png)

这是三个程序同时挤在一个物理内存上的情况，看起来相安无事，但如果A程序出现程序错误，将B程序的內存地址2000加载到了寄存器中，进行了写入操作，那么B程序就被影响了，此时就可能发生不幸的事情。

我们想要将程序隔离开来，互相不受影响，也就是说，程序A能从地址0增长到n，程序B也可以，程序C也可以。

![](https://s2.loli.net/2022/03/17/2ZezYqafFGEQnX5.png)

如图所示，三个程序互不影响，程序A向地址2000写入数据，那就是对它自己的地址2000写入数据，程序B同理。他们的地址空间相互独立，互不干扰，这就是我们想要达到的目标。当然了，这里程序所写入数据的地址，其实是虚拟地址，程序A对应的地址2000，不一定是物理地址的2000。但事实上，三个程序实际使用的內存，还是物理内存。

至于虚拟地址如何转换为物理地址，这要通过每个程序的地址空间存在的从虚拟地址到物理地址的映射关系来实现，具体的实现是通过硬件来进行转换的，涉及到MMU和TLB等硬件机制。

那么还有一个问题：物理内存是有限的，程序自以为在使用所有的內存，这会导致內存不够用吗？答案是不会的，虚拟内存甚至可以设置到比物理内存还大，这里是通过页表实现的，但是物理内存始终是有限的，那就意味着內存是会耗尽的，判断內存耗尽也是一个重要的事情。
