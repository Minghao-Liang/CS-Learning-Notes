# 宏内核与微内核

## 宏内核

前面谈到CPU可以执行不同的模式，如果整个操作系统都驻留在内核中，操作系统所有的模块实现都在supervisor mode下运行，那么这种组织方式就被称为宏内核（monolithic kernel），又称为单内核。例如xv6、Linux就是宏内核的操作系统。宏内核操作系统具有强大的抽象能力，比如，它提供文件系统这样的组件，将文件、目录、文件描述符作为文件系统的接口，而不是将磁盘硬件直接暴露给应用程序。这样做使得宏内核具有很多优势。

其一是这些高度抽象的接口是可移植的，你不需要考虑文件是运行在什么磁盘上，是不同牌子，还是SSD或者HDD，都不重要了。在高度抽象下具有相同的系统接口，具有很强的可移植性，可以运行在不同的硬件上。然后是这样的组织方式可以向应用程序隐藏复杂性，内核中的复杂行为，在外界看来只需要对接口做一些简单的操作，这样对使用者来说很舒适，但是内核同时会变得很大很复杂。

还有就是像文件系统、内存分配、调度器、虚拟内存系统等都是集成在一个巨大的内核中，这意味着它们可以互相访问彼此的数据结构，使得各个部分中的功能实现更为容易，比如exec系统调用以来文件系统，同时也以来内存分配和虚拟内存系统，如果各个部分是分离的，实现exec系统调用将需要更大的开销。

宏内核的组织方式非常方便，设计者无需考虑哪一部分不需要硬件的特权，而且操作系统的不同部分之间合作起来也更加方便，各种子模块紧密连接在一起也使得系统具有更好的性能。

但是，在宏内核中也有一些缺陷是不可避免的。比如，内核中任何一个bug都有可能成为漏洞，牵一发而动全身。如果这个操作系统有大量的代码，出现严重bug的可能性也更大。而如今的操作系统都具有巨量的代码，在这种情况下宏内核很难满足特定场景下对安全性、可靠性等方面的需求。

此外，宏内核是如此之大，或者说发展到今天它是太大了，包含了大量的内容，但是这些功能模块需要去做所有的事情吗？如果对各种不同场景都能支持，那么针对特定场景的性能优化会变得困难，巨大的宏内核系统的通用性也意味着它会变慢。还有一个问题是可扩展性较弱，应用程序如果想实时更改内核，至少在十年前是做不到的，只能使用内核提供的能力。

## 微内核

除此之外，还具有另一种组织方式，称为微内核（microkernel）。微内核的核心是进程间通信IPC（Inter-Process Communication），所有你想做的事情都是通过用户空间的进程来实现的，完全不会在内核中实现。设计者将操作系统的单个功能或者模块从内核中拆分出来，在user mode下执行大部分的功能，仅在内核中运行少部分的代码。在微内核中，各个模块之间相互隔离，在安全性方面可以做得更好，而且独立的模块也能更好地为不同场景定制不一样的功能。

在微内核中唯一需要做的事情就是支持进程/任务/线程，以及通过支持IPC来作为消息的传递途径，除此之外，内核不需要做任何事情。

在实际中，两种设计都有出现，历史上大部分桌面操作系统都是宏内核，而很多嵌入式系统是微内核。关于宏内核与微内核之间的讨论也远没有这么简单。

### 微内核的动机和挑战

为什么我们需要构建微内核？或许我们会觉得，微内核看起来更优雅。

当然，审美只是一方面，还有一些更具体的动机。

首先是更小的内核或许会更安全，内核小的话bug也不会太多，少量的代码也更容易被优化。而且，小的内核的设计限制也更小，更加灵活，应用程序可以根据自己的设计做出相应的调整。与此同时，人们认为微内核更容易被定制化，可也以在微内核上神奇事情，比如说在微内核上再运行多个操作系统。

除了好处，微内核也会带来一些挑战，首先是微内核的系统调用要尽可能少，但是它有需要尽可能多地去支持人们要做的各种事情，如何做到具有简单的系统调用的同时做更多的工作是一个设计上的挑战。

然后微内核的设计需要进程间通过IPC进行大量的通信，这意味着需要IPC足够快，而且在这个过程中不断切换模式，是否会带来性能的损失？IPC可以做到足够快来保证微内核的优势吗？此外宏内核中各个模块交互更容易，微内核由于分离，那么集成的时候优化也会变得更加困难，这或许也会影响性能。