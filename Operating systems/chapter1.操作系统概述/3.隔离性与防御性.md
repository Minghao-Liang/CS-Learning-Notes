# 隔离性与防御性

## 隔离性

我们来说说隔离性（isolation）。

隔离性的思想很简单，顾名思义，就是把用户空间的应用程序隔离开来。在用户空间中有多个程序，当一个程序出问题时，我们并不希望该程序会影响到其他程序的运行。如果一个程序出问题时，把其他程序也顺带干掉了，那么这是一件很可怕很糟糕的事情。试着想想，当你使用查找文件时，查找文件的程序出了问题，导致影响了删除文件的程序，就把你的文件给删掉了，这是一件很恐怖的事情吧。所以我们在不同的程序之间要有强隔离性。

操作系统其实也是一个程序，我们不希望在一个应用程序出问题时操作系统因此而崩溃。比如说操作系统接收到了一些奇怪的参数，但我们希望操作系统能够很好地处理这些奇怪的参数，即可以很好地处理异常情况，所以操作系统和应用程序之间自然也需要有强隔离性。

这里举一个简单的反例，如果没有操作系统，应用程序就可以直接和底层的硬件交互，比如说CPU就暴露在了应用程序严重，同时也可以看到磁盘、內存等。这种情况是会出现应用程序之间的隔离性被破坏的情况的，当应用程序在CPU上运行时，理应让别的程序也有机会运行，但这时没有了操作系统，操作系统没有提供虚拟化CPU的假象（简单来说，虚拟化CPU就是指程序以为自己在独自占有CPU，然后看起来有无数个CPU在供不同程序使用，而事实上是操作系统在调度），如果此时运行着的程序中出现了死循环，那么它将永远霸占CPU，我们甚至无法运行杀死它的程序。

不仅是CPU，內存也是如此，同样的，內存也存在虚拟化现象，让程序以为自己独自霸占了所有的物理内存，但事实上不是，如果两个程序在运行时出现抢占对方内存的情况，覆盖了对方内存中的内容，那么程序的运行必然会出问题。

我们当然不想上述的情况发生，所以此时可以体现隔离性的重要了。

系统调用的接口是精心设计的，通过抽象硬件资源，提供了强隔离性的功能。

## 防御性

还有另一个思想——防御性（defensive）。

防御性是指操作系统能很好的抵御来自应用程序的攻击，或者说，如果应用程序恶意向操作系统传输一些错误的参数，这些参数有可能会使操作系统崩溃，没错，就像被黑客入侵一样，一旦攻击者打破了隔离，掌控了内核，就可以肆意妄为，这样的情况显然不是我们想看到的。所以，操作系统需要应对恶意的应用程序，做出防御。

在开发内核的过程中，防御性的思想无疑是重要的，我们必须时刻思考如何通过防御性的思想打造一个具有强大防御能力的内核，保证在运行的过程中的安全。

通常来说，硬件可以提供一些帮助。

## 硬件支持

为强隔离性提供了硬件支持的是CPU，RISC-V架构中有三种CPU可以执行的模式：machine mode，user mode，supervisor mode。

Machine mode下执行的指令具有完全特权，在这里不过多讨论，该模式主要用于配置计算机，操作系统很快就会进入supervisor mode。在supervisor mode下CPU可以执行特权级指令，在user mode下如果想执行特权级指令，这是不被允许的，CPU不会执行，user mode下只能执行普通指令，如果user mode尝试执行特权级指令，此时会切换到supervisor mode，然后可以终止程序运行，因为它做了不该做的事情。应用程序只能执行user mode下的指令，在用户空间中运行，而内核可以执行supervisor mode下的特权级指令，在内核空间中运行。

由此可以看到硬件是通过分成三种模式执行不同权限级别的指令来实现强隔离性的。

至于內存上的隔离，这个会在虚拟内存中提到。