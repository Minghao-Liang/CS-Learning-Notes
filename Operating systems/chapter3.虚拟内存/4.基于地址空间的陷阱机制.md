# 基于地址空间的陷阱机制

程序运行是完成用户空间到内核空间的切换，在这里，我们通常称为trap，也就是陷阱机制，在下列的情形中会发生这种切换：

1. 系统调用（system call）：当用户程序执行`ecall`指令要求内核为其做些什么时
2. 异常（exception）：用户指令或内核指令做了一些非法的事情，例如除以零或使用无效的虚拟地址
3. 设备中断（device interrupt）：一个设备，例如当磁盘硬件完成读或写请求时，向系统表明它需要被关注

在RISC-V的CPU中有一组控制寄存器，内核向这些寄存器写入内容来告诉CPU如何处理陷阱。

以下是一些最重要的寄存器的概述：

- `stvec`：内核在这里写入其陷阱处理程序的地址；RISC-V跳转到这里处理陷阱。
- `sepc`：当发生陷阱时，RISC-V会在这里保存程序计数器`pc`（因为`pc`会被`stvec`覆盖）。`sret`（从陷阱返回）指令会将`sepc`复制到`pc`。内核可以写入`sepc`来控制`sret`的去向。
- `scause`： RISC-V在这里放置一个描述陷阱原因的数字。
- `sscratch`：内核在这里放置了一个值，这个值在陷阱处理程序一开始就会派上用场。
- `sstatus`：其中的SIE位控制设备中断是否启用。如果内核清空SIE，RISC-V将推迟设备中断，直到内核重新设置SIE。SPP位指示陷阱是来自用户模式还是管理模式，并控制`sret`返回的模式。

这些寄存器都在supervisor mode下处理陷阱，在user mode下不能读或写。

需要强制执行陷阱时，RISC-V对除计时器中断以外陷阱类型执行以下操作：

1. 如果陷阱是设备中断，并且状态SIE位被清空，则不执行以下任何操作。
2. 清除SIE以禁用中断。
3. 将`pc`复制到`sepc`。
4. 将当前模式（用户或管理）保存在状态的SPP位中。
5. 设置`scause`以反映产生陷阱的原因。
6. 将模式设置为管理模式。
7. 将`stvec`复制到`pc`。
8. 在新的`pc`上开始执行。

这里需要注意的是，CPU并不具备切换内核页表、内核栈和保存其他寄存器的能力，需要内核软件去做这些任务。这样做的原因是CPU可以在陷阱时做尽量少的工作，为软件提供灵活性，比如，并不是所有操作系统都需要在这个时候切换页表的，盲目切换反而降低了性能。

## 从用户空间陷入

首先，我们来讨论一下从用户空间陷入陷阱的情况。当用户程序发生了开头所讲的三种情况时，就会产生陷阱。下面我们以xv6系统为例，用一幅图来描述从用户空间执行陷阱的过程。

<img src="https://s2.loli.net/2022/07/03/L8xQAH6IDysFpOG.png" alt="用户空间陷入.png" style="zoom: 50%;" />

系统调用执行`ecall`指令，执行下列操作：

1. 如果陷阱是设备中断，并且状态SIE位被清空，则不执行以下任何操作
2. 清除SIE以禁用中断
3. user mode 转移到 supervisor mode
4. `sepc` = `pc`
5. `pc` = `stvec`
6. 跳转到`pc`
7. 设置`scause`以反映产生陷阱的原因
8. 将当前模式（用户或管理）保存在状态的SPP位中

然后进入了一个由汇编语言写的函数`uservec`，在该函数中，保存32个通用寄存器，把内核页表、内核的栈和执行该进程的CPU号保存到寄存器中。

接着代码跳转到了由C语言首先的函数`usertrap`中，在这个函数里根据具体情况处理陷阱，修改`stvec`寄存器.

执行了系统调用之后，我们需要让用户空间的代码恢复执行，所以`syscall`函数会调用`usertrapret`函数，该函数会存储当前内核页表的指针、当前用户进程的内核栈，还会存储`usertrap`函数的指针和CPU的号，该函数还会恢复`stvec`和`sepc`的值。

除此之外，还有一些工作必须在汇编语言中完成，于是进入`userret`函数，程序切换回到用户空间，将`sepc`寄存器的数值拷贝到`pc`，然后重新打开中断。