# 多级页表

在SV39模式中，采用的是三级页表，我们以此为例来看看多级页表的机制是怎么样的。下面是SV39地址转换的过程图（图源MIT6.S081）：

<img src="https://s2.loli.net/2022/03/19/UslCxtjqvrGoSbH.png" style="zoom: 67%;" />

可以看到，我们之前所说的27位的索引，实际上分为了三个等长的索引，分别是图中的L2、L1、L0。所以我们可以将页表分为三级页表，一个虚拟地址通过三级页表转换为物理地址。在这里，每个页表都是用九位索引的，所以有$2^{9}=512$个PTE，这样看来，是不是比$2^{27}$要小得多？很显然，相比于前一个只有一级页表方案，这个三级页表的方案所需的空间大大减少了。

我们来看看虚拟地址是怎么转换为物理地址的。

首先，这里有一个satp寄存器，这个寄存器在RISC-V中是用来存储根页表的地址的。所以satp寄存器会指向最高一级的页表的物理地址，然后我们用高9位来索引最高一级页表，这里可以得到一个PPN，指向中间级页表，同样的过程在中间级页表和最低级页表之间进行。在最低级页表中，我们可以得到虚拟地址对应的物理地址。事实上，这个过程和前一个方案是类似的，只不过把只需一步的索引分成三步进行。

接下来看看PTE中的标志位。

- V：如果V为1，说明这是一条合法的PTE，可以用它来做地址翻译。
- R/W：我想这个很明显了，这表明你是否可以读/写。
- X：表明你是否可以从这一页执行指令。
- U：表明这一页可以被运行在用户空间的进程访问。

这是最重要的几个标志位，其他标志位的功能可以按需查找。

注意，三级页表是由硬件实现的。

## TLB(Translation Lookaside Buffer)

或许经常看见过TLB这个词，它的翻译有快表、转换后备缓冲区、页表缓存。这里我们统一称为TLB。

对于上面的三级页表，一个虚拟地址的寻址读取三次內存，或许有点多了，每次读取必然要付出某些代价。至于是什么代价，这里不深究。为了解决这个问题，在实际中，处理器会对最近使用过的虚拟地址的翻译结果有缓存，这个缓存就是TLB。

当一个处理器第一次查找一个虚拟地址，硬件通过三次查找得到了最终的物理地址，而TLB会保存其中虚拟地址与物理地址的映射关系，当下一次访问这个虚拟地址时，不需要再对页表进行一通操作，而是由TLB给出这个物理地址。

这里还有一个问题，当你切换了页表，操作系统就会告诉处理器，然后处理器会清空TLB，因为一旦你切换了页表，TLB原有的缓存就没用了，它属于原来的页表。清空TLB所用到的指令是sfence.vma。